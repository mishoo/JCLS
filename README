                    JCLS: Java-Common-Lisp-Script
                         (c) Mihai Bazon 2011
                     http://mihai.bazon.net/blog

----------------------------------------------------------------------

        Any sufficiently complicated C or Fortran program contains an
        ad hoc, informally-specified, bug-ridden, slow implementation
        of half of Common Lisp.

                                             Greenspun's Tenth Rule

----------------------------------------------------------------------

The following section was the original README, but it's not quite true
anymore.  We don't have dynamic variables now, nor CATCH / THROW /
IGNORE-ERRORS / UNWIND-PROTECT.

On the plus side, we have CALL/CC, a trampoline-style evaluator (so
infinite recursion won't blow the stack) and a nice browser-based demo
(open browser/index.html, put it behind a real Web server so that
samples would work; avoid IE or Opera for this test; avoid IE in
general.)

If you have an error in your program, you might have the surprise to
not see any error report whatsoever, and instead the editor will
refuse to listen to your key bindings and the only possible "fix" will
be to refresh the page.  I could improve this, but it doesn't worth
the trouble.

This is how it ends.  Progress is unlikely, I need to start all over.

----------------------------------------------------------------------

This is a toy Lisp interpreter in JavaScript.  It follows the wisdom
brought to us by prophets in SICP 4:1:7 to implement an analyze
function that breaks the Lisp program into JavaScript closures.  It's
probably not usable for real programming, as the interpreter is
recursive and could blow the stack quite easily.

Current features:  (see tmp/test.lisp for some disorganized tests)

- basic Lisp stuff: CONS, LIST, C[AD]+R, QUOTE, IF, LAMBDA etc.
- CL-style packages (supports private symbols, etc.)
- lexical and dynamic variables
- FLET, LABELS, DEFUN, DEFMACRO, MACROEXPAND-1
- CL-style lambda lists (&key, &optional, &body, DESTRUCTURING-BIND)
- the quasiquote operator
- CATCH, THROW, IGNORE-ERRORS, UNWIND-PROTECT
- the ability to influence the reader (SET-MACRO-CHARACTER)

It's not remotely close to half of Common Lisp, as you can see, but
maybe we can get closer.  I'm planning to change the analyze function
to continuation-passing style (as in SICP 4:3:3) and use a trampoline
instead of doing tail calls, which should (if the resulting
interpreter won't be unbearably slow) make it useful for real-world
problems.

----------------------------------------------------------------------
